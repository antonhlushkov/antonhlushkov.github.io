<style>
    .nodes-container {
      position: relative;
      width: 100%;
      height: 300px;
      overflow: hidden;
      background: transparent;
    }

    .obsidian-graph {
      width: 100%;
      height: 100%;
      overflow: hidden;
      position: relative;
    }

    .obsidian-graph svg {
      width: 100%;
      height: 100%;
      cursor: grab;
      display: block;
      touch-action: none;
      -webkit-user-select: none;
      -webkit-touch-callout: none;
    }

    .obsidian-graph svg.panning {
      cursor: grabbing;
    }

    .obsidian-graph .link {
      stroke: #3a3f4b;
      stroke-width: 1.2;
    }

    .obsidian-graph .node {
      cursor: pointer;
      -webkit-user-select: none;
      -webkit-touch-callout: none;
    }

    @media (hover: none) and (pointer: coarse) {
      .obsidian-graph .node:active circle {
        fill: #333333;
      }
    }

    .obsidian-graph .node circle {
      fill: #000000;
      stroke: none;
      stroke-width: 0;
      transition: r 0.2s ease;
    }

    .obsidian-graph .node:hover circle {
      stroke: none;
      stroke-width: 0;
    }

    .obsidian-graph .node text {
      fill: #000000;
      font-size: 12px;
      font-weight: 500;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
      background-color: yellow;
      text-anchor: middle;
      pointer-events: none;
      user-select: none;
    }

    .map-fade-overlay-bottom {
      position: absolute;
      bottom: 0;
      left: 0;
      width: 100%;
      height: 100px;
      pointer-events: none;
      background: linear-gradient(
        to bottom,
        rgba(255, 255, 255, 0) 0%,
        rgba(255, 255, 255, 0.3) 40%,
        rgba(255, 255, 255, 0.8) 80%,
        rgba(255, 255, 255, 1) 100%
      );
      z-index: 1000;
    }

    .map-fade-overlay-top {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100px;
      pointer-events: none;
      background: linear-gradient(
        to bottom,
        rgba(255, 255, 255, 1) 0%,
        rgba(255, 255, 255, 0.8) 20%,
        rgba(255, 255, 255, 0.3) 60%,
        rgba(255, 255, 255, 0) 100%
      );
      z-index: 1000;
    }

    .info-text {
      display: none;
    }
  </style>
  <div class="nodes-container">
    <div class="map-fade-overlay-top"></div>
    <div id="graph"></div>
    <div class="map-fade-overlay-bottom"></div>
    <div class="info-text">Drag to pan • Scroll to zoom • Double-click nodes to open links</div>
  </div>

  <script>
    // ===== CONFIGURATION =====
    const CONFIG = {
      circleRadius: 6,
      springLength: 320,
      springStrength: 0.015,
      repulsion: 2000,
      damping: 0.82,
      circleFill: '#000000',
      textColor: '#000000',
      textSize: 12,
      linkColor: '#3a3f4b',
      linkStrokeWidth: 1.2,
    };

    function createGraph(container, nodes, links, options = {}) {
      const CIRCLE_RADIUS = options.circleRadius ?? CONFIG.circleRadius;
      const SPRING_LENGTH = options.springLength ?? CONFIG.springLength;
      const SPRING_FORCE = options.springStrength ?? CONFIG.springStrength;
      const REPULSION_FORCE = options.repulsion ?? CONFIG.repulsion;
      const DAMPING = options.damping ?? CONFIG.damping;

      container.classList.add("obsidian-graph");

      const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
      const viewport = document.createElementNS(svg.namespaceURI, "g");
      svg.appendChild(viewport);
      container.appendChild(svg);

      const bounds = () => container.getBoundingClientRect();

      let scale = 1;
      let panX = 0;
      let panY = 0;
      let panning = false;

      const nodeById = Object.fromEntries(nodes.map(n => [n.id, n]));

      // INITIAL SPAWN - circular arrangement
      const spawnRadius = 140;
      nodes.forEach((n, i) => {
        const angle = (i / nodes.length) * Math.PI * 2;
        n.x = Math.cos(angle) * spawnRadius;
        n.y = Math.sin(angle) * spawnRadius;
        n.vx = 0;
        n.vy = 0;
      });

      // Create links
      const linkEls = links.map(l => {
        const el = document.createElementNS(svg.namespaceURI, "line");
        el.classList.add("link");
        viewport.appendChild(el);
        return {
          el,
          a: nodeById[l.a],
          b: nodeById[l.b]
        };
      });

      // Helper function to wrap text
      function wrapText(text, maxWidth = 30) {
        const words = text.split(' ');
        const lines = [];
        let currentLine = '';

        words.forEach(word => {
          if ((currentLine + word).length > maxWidth) {
            if (currentLine) lines.push(currentLine.trim());
            currentLine = word;
          } else {
            currentLine += (currentLine ? ' ' : '') + word;
          }
        });

        if (currentLine) lines.push(currentLine.trim());
        return lines.length > 0 ? lines : [text];
      }

      // Create nodes
      const nodeEls = nodes.map(n => {
        const g = document.createElementNS(svg.namespaceURI, "g");
        g.classList.add("node");
        g.style.userSelect = "none";

        const circle = document.createElementNS(svg.namespaceURI, "circle");
        circle.setAttribute("r", CIRCLE_RADIUS);

        const text = document.createElementNS(svg.namespaceURI, "text");
        text.setAttribute("y", CIRCLE_RADIUS + 15);

        // Wrap text into multiple lines
        const lines = wrapText(n.id, 12);
        lines.forEach((line, index) => {
          const tspan = document.createElementNS(svg.namespaceURI, "tspan");
          tspan.setAttribute("x", "0");
          tspan.setAttribute("dy", index === 0 ? "0" : "1.2em");
          tspan.textContent = line;
          text.appendChild(tspan);
        });

        g.appendChild(circle);
        g.appendChild(text);
        viewport.appendChild(g);

        // Handle click navigation
        if (n.url) {
          g.addEventListener("click", () => {
            window.location.href = n.url;
          });
        }

        enableDrag(g, n);
        return { g, n };
      });

      // Physics simulation
      function tick() {
        // Spring forces
        for (const l of linkEls) {
          const dx = l.b.x - l.a.x;
          const dy = l.b.y - l.a.y;
          const d = Math.hypot(dx, dy) || 1;
          const force = (d - SPRING_LENGTH) * SPRING_FORCE;
          const fx = (force * dx) / d;
          const fy = (force * dy) / d;

          l.a.vx += fx;
          l.a.vy += fy;
          l.b.vx -= fx;
          l.b.vy -= fy;
        }

        // Repulsion forces
        for (let i = 0; i < nodes.length; i++) {
          for (let j = i + 1; j < nodes.length; j++) {
            const a = nodes[i];
            const b = nodes[j];
            const dx = b.x - a.x;
            const dy = b.y - a.y;
            const d2 = dx * dx + dy * dy;

            if (d2 > 40000) continue;

            const d = Math.sqrt(d2) || 1;
            const force = REPULSION_FORCE / d2;
            const fx = (force * dx) / d;
            const fy = (force * dy) / d;

            a.vx -= fx;
            a.vy -= fy;
            b.vx += fx;
            b.vy += fy;
          }
        }

        // Integrate velocities
        for (const n of nodes) {
          n.x += n.vx;
          n.y += n.vy;
          n.vx *= DAMPING;
          n.vy *= DAMPING;
        }

        render();
        requestAnimationFrame(tick);
      }

      let frameCount = 0;
      const COLLISION_CHECK_INTERVAL = 15; // Check collision every 15 frames

      function render() {
        // Update links
        for (const l of linkEls) {
          l.el.setAttribute("x1", l.a.x);
          l.el.setAttribute("y1", l.a.y);
          l.el.setAttribute("x2", l.b.x);
          l.el.setAttribute("y2", l.b.y);
        }

        // Update nodes
        for (const o of nodeEls) {
          o.g.setAttribute("transform", `translate(${o.n.x}, ${o.n.y})`);
        }

        // Only run collision detection every N frames to prevent twitching
        frameCount++;
        if (frameCount % COLLISION_CHECK_INTERVAL === 0) {
          // Prevent text overlap using smart positioning
          const textData = nodeEls.map(o => {
            const text = o.g.querySelector("text");
            return {
              text,
              x: o.n.x,
              y: o.n.y,
              node: o
            };
          });

          // Iteratively adjust text positions to avoid overlap
          for (let iteration = 0; iteration < 2; iteration++) {
            for (let i = 0; i < textData.length; i++) {
              const current = textData[i];
              let bestY = 21;
              let bestX = 0;
              let minOverlap = Infinity;

              // Try different positions around the dot
              const positions = [
                { x: 0, y: 21 },    // Below
                { x: 0, y: -21 },   // Above
                { x: 25, y: 8 },    // Right-down
                { x: -25, y: 8 },   // Left-down
                { x: 25, y: -8 },   // Right-up
                { x: -25, y: -8 },  // Left-up
              ];

              for (const pos of positions) {
                let overlap = 0;

                // Check overlap with all other texts
                for (let j = 0; j < textData.length; j++) {
                  if (i === j) continue;
                  const other = textData[j];
                  
                  // Calculate distance between this position and other text
                  const currentScreenX = current.x + pos.x;
                  const currentScreenY = current.y + pos.y;
                  const otherScreenX = other.x + (parseFloat(other.text.getAttribute("x")) || 0);
                  const otherScreenY = other.y + (parseFloat(other.text.getAttribute("y")) || 0);

                  const dx = currentScreenX - otherScreenX;
                  const dy = currentScreenY - otherScreenY;
                  const distance = Math.hypot(dx, dy);

                  // Penalize positions too close to other text
                  if (distance < 50) {
                    overlap += (50 - distance);
                  }
                }

                if (overlap < minOverlap) {
                  minOverlap = overlap;
                  bestY = pos.y;
                  bestX = pos.x;
                }
              }

              current.text.setAttribute("x", bestX);
              current.text.setAttribute("y", bestY);
            }
          }
        }
      }

      function enableDrag(el, n) {
        let isDragging = false;
        let touchId = null;

        // Mouse drag
        el.addEventListener("mousedown", e => {
          isDragging = true;
          e.stopPropagation();
        });

        window.addEventListener("mousemove", e => {
          if (!isDragging) return;
          n.x += e.movementX / scale;
          n.y += e.movementY / scale;
          n.vx = 0;
          n.vy = 0;
        });

        window.addEventListener("mouseup", () => {
          isDragging = false;
        });

        // Touch drag
        el.addEventListener("touchstart", e => {
          if (e.touches.length === 1) {
            isDragging = true;
            touchId = e.touches[0].identifier;
            e.stopPropagation();
          }
        });

        window.addEventListener("touchmove", e => {
          if (!isDragging || touchId === null) return;
          
          let touchPoint = null;
          for (let i = 0; i < e.touches.length; i++) {
            if (e.touches[i].identifier === touchId) {
              touchPoint = e.touches[i];
              break;
            }
          }
          
          if (!touchPoint) return;
          
          const lastTouch = el._lastTouchPoint || touchPoint;
          const dx = touchPoint.clientX - lastTouch.clientX;
          const dy = touchPoint.clientY - lastTouch.clientY;
          
          n.x += dx / scale;
          n.y += dy / scale;
          n.vx = 0;
          n.vy = 0;
          
          el._lastTouchPoint = { clientX: touchPoint.clientX, clientY: touchPoint.clientY };
        });

        window.addEventListener("touchend", e => {
          for (let i = 0; i < e.changedTouches.length; i++) {
            if (e.changedTouches[i].identifier === touchId) {
              isDragging = false;
              touchId = null;
              el._lastTouchPoint = null;
              break;
            }
          }
        });

        window.addEventListener("touchcancel", () => {
          isDragging = false;
          touchId = null;
          el._lastTouchPoint = null;
        });
      }

      function centerGraph() {
        let minX = Infinity,
          minY = Infinity,
          maxX = -Infinity,
          maxY = -Infinity;

        for (const n of nodes) {
          minX = Math.min(minX, n.x);
          minY = Math.min(minY, n.y);
          maxX = Math.max(maxX, n.x);
          maxY = Math.max(maxY, n.y);
        }

        const centerX = (minX + maxX) / 2;
        const centerY = (minY + maxY) / 2;
        const b = bounds();

        panX = b.width / 2 - centerX * scale;
        panY = b.height / 2 - centerY * scale;
        updateView();
      }

      function updateView() {
        viewport.setAttribute("transform", `translate(${panX}, ${panY}) scale(${scale})`);
      }

      // Zoom
      svg.addEventListener("wheel", e => {
        e.preventDefault();
        const oldScale = scale;
        scale *= e.deltaY > 0 ? 0.9 : 1.1;
        updateView();
      });

      // Pan with mouse
      svg.addEventListener("mousedown", e => {
        if (e.target === svg) {
          panning = true;
          svg.classList.add("panning");
        }
      });

      window.addEventListener("mousemove", e => {
        if (!panning) return;
        panX += e.movementX;
        panY += e.movementY;
        updateView();
      });

      window.addEventListener("mouseup", () => {
        panning = false;
        svg.classList.remove("panning");
      });

      // Touch panning and pinch zoom
      let touchStartX = 0;
      let touchStartY = 0;
      let lastTouchDistance = 0;

      svg.addEventListener("touchstart", e => {
        if (e.touches.length === 1) {
          touchStartX = e.touches[0].clientX;
          touchStartY = e.touches[0].clientY;
          panning = true;
          svg.classList.add("panning");
        } else if (e.touches.length === 2) {
          const dx = e.touches[0].clientX - e.touches[1].clientX;
          const dy = e.touches[0].clientY - e.touches[1].clientY;
          lastTouchDistance = Math.hypot(dx, dy);
          panning = false;
        }
      });

      svg.addEventListener("touchmove", e => {
        e.preventDefault();
        if (e.touches.length === 1 && panning) {
          const dx = e.touches[0].clientX - touchStartX;
          const dy = e.touches[0].clientY - touchStartY;
          panX += dx;
          panY += dy;
          touchStartX = e.touches[0].clientX;
          touchStartY = e.touches[0].clientY;
          updateView();
        } else if (e.touches.length === 2) {
          const dx = e.touches[0].clientX - e.touches[1].clientX;
          const dy = e.touches[0].clientY - e.touches[1].clientY;
          const distance = Math.hypot(dx, dy);
          if (lastTouchDistance > 0) {
            const zoomFactor = distance / lastTouchDistance;
            scale *= zoomFactor;
            scale = Math.max(0.1, Math.min(5, scale));
            updateView();
          }
          lastTouchDistance = distance;
        }
      });

      svg.addEventListener("touchend", e => {
        panning = false;
        svg.classList.remove("panning");
        lastTouchDistance = 0;
      });

      svg.addEventListener("touchcancel", e => {
        panning = false;
        svg.classList.remove("panning");
        lastTouchDistance = 0;
      });

      // Observe container resize
      new ResizeObserver(() => {
        centerGraph();
      }).observe(container);

      // Start simulation
      centerGraph();
      tick();
    }

    // Skills data
    const nodes = [
      { id: "Windows OS administration", url: "#windows-os" },
      { id: "Hardware & peripheral support", url: "#hardware-support" },
      { id: "User access management", url: "#user-access" },
      { id: "Troubleshooting & incident resolution", url: "#troubleshooting" },
      { id: "IT asset management", url: "#it-asset" },
      { id: "Administration of medical information systems (MIS)", url: "#mis-admin" },
      { id: "Basic database administration (user access, data integrity)", url: "#db-admin" },
      { id: "Data entry validation and system support", url: "#data-validation" },
      { id: "Working with sensitive medical data", url: "#sensitive-data" },
      { id: "Information security controls", url: "#info-security" },
      { id: "Access control policies", url: "#access-policies" },
      { id: "Data protection practices", url: "#data-protection" },
      { id: "Work within critical infrastructure environments", url: "#critical-infra" },
      { id: "Compliance awareness", url: "#compliance" },
      { id: "JavaScript (basic–intermediate)", url: "#javascript" },
      { id: "Node.js, Express.js", url: "#nodejs-express" },
      { id: "HTML, CSS", url: "#html-css" },
      { id: "REST API basics", url: "#rest-api" },
      { id: "Documentation & reporting", url: "#documentation" },
      { id: "Time management (dual part-time roles)", url: "#time-management" },
      { id: "Team collaboration", url: "#team-collaboration" },
      { id: "Fast learner, adaptable", url: "#fast-learner" }
    ];

    const links = [
      // Core IT support connections
      { a: "Windows OS administration", b: "Hardware & peripheral support" },
      { a: "Windows OS administration", b: "Troubleshooting & incident resolution" },
      { a: "Hardware & peripheral support", b: "Troubleshooting & incident resolution" },
      { a: "Windows OS administration", b: "IT asset management" },
      { a: "Hardware & peripheral support", b: "IT asset management" },

      // User and access management
      { a: "User access management", b: "Basic database administration (user access, data integrity)" },
      { a: "User access management", b: "Access control policies" },
      { a: "Access control policies", b: "Information security controls" },

      // Medical and data handling
      { a: "Administration of medical information systems (MIS)", b: "Working with sensitive medical data" },
      { a: "Administration of medical information systems (MIS)", b: "Data entry validation and system support" },
      { a: "Working with sensitive medical data", b: "Data protection practices" },
      { a: "Data protection practices", b: "Information security controls" },
      { a: "Basic database administration (user access, data integrity)", b: "Data entry validation and system support" },

      // Infrastructure and compliance
      { a: "Work within critical infrastructure environments", b: "Compliance awareness" },
      { a: "Work within critical infrastructure environments", b: "Information security controls" },
      { a: "Compliance awareness", b: "Data protection practices" },

      // Programming and development
      { a: "JavaScript (basic–intermediate)", b: "Node.js, Express.js" },
      { a: "JavaScript (basic–intermediate)", b: "HTML, CSS" },
      { a: "Node.js, Express.js", b: "REST API basics" },
      { a: "HTML, CSS", b: "REST API basics" }, // Loose connection via web dev

      // Soft skills connections to technical areas
      { a: "Documentation & reporting", b: "Troubleshooting & incident resolution" },
      { a: "Documentation & reporting", b: "Compliance awareness" },
      { a: "Time management (dual part-time roles)", b: "Team collaboration" },
      { a: "Team collaboration", b: "Fast learner, adaptable" },
      { a: "Fast learner, adaptable", b: "JavaScript (basic–intermediate)" }, // Adaptability in learning tech
      { a: "Fast learner, adaptable", b: "Troubleshooting & incident resolution" },

      // Cross-links between categories
      { a: "Administration of medical information systems (MIS)", b: "Windows OS administration" }, // OS admin in MIS
      { a: "Basic database administration (user access, data integrity)", b: "Information security controls" },
      { a: "IT asset management", b: "Work within critical infrastructure environments" },
      { a: "REST API basics", b: "Basic database administration (user access, data integrity)" } // APIs often interact with DBs
    ];

    // Initialize graph
    document.addEventListener("DOMContentLoaded", () => {
      createGraph(document.getElementById("graph"), nodes, links);
    });
  </script>
