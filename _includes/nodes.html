<style>
    .nodes-container {
      position: relative;
      width: 100%;
      height: 300px;
      overflow: hidden;
      background: transparent;
    }

    .obsidian-graph {
      width: 100%;
      height: 100%;
      overflow: hidden;
      position: relative;
    }

    .obsidian-graph svg {
      width: 100%;
      height: 100%;
      cursor: grab;
      display: block;
    }

    .obsidian-graph svg.panning {
      cursor: grabbing;
    }

    .obsidian-graph .link {
      stroke: #3a3f4b;
      stroke-width: 1.2;
    }

    .obsidian-graph .node {
      cursor: pointer;
    }

    .obsidian-graph .node circle {
      fill: #000000;
      stroke: none;
      stroke-width: 0;
      transition: r 0.2s ease;
    }

    .obsidian-graph .node:hover circle {
      stroke: none;
      stroke-width: 0;
    }

    .obsidian-graph .node text {
      fill: #000000;
      font-size: 12px;
      font-weight: 500;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
      background-color: yellow;
      text-anchor: middle;
      pointer-events: none;
      user-select: none;
    }

    .map-fade-overlay-bottom {
      position: absolute;
      bottom: 0;
      left: 0;
      width: 100%;
      height: 120px;
      pointer-events: none;
      background: linear-gradient(
        to bottom,
        rgba(255, 255, 255, 0) 0%,
        rgba(255, 255, 255, 0.3) 40%,
        rgba(255, 255, 255, 0.8) 80%,
        rgba(255, 255, 255, 1) 100%
      );
      z-index: 1000;
    }

    .map-fade-overlay-top {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 120px;
      pointer-events: none;
      background: linear-gradient(
        to bottom,
        rgba(255, 255, 255, 1) 0%,
        rgba(255, 255, 255, 0.8) 20%,
        rgba(255, 255, 255, 0.3) 60%,
        rgba(255, 255, 255, 0) 100%
      );
      z-index: 1000;
    }

    .info-text {
      display: none;
    }
  </style>
</head>
<body>
  <div class="nodes-container">
    <div class="map-fade-overlay-top"></div>
    <div id="graph"></div>
    <div class="map-fade-overlay-bottom"></div>
    <div class="info-text">Drag to pan • Scroll to zoom • Double-click nodes to open links</div>
  </div>

  <script>
    // ===== CONFIGURATION =====
    const CONFIG = {
      circleRadius: 6,
      springLength: 120,
      springStrength: 0.015,
      repulsion: 6000,
      damping: 0.82,
      circleFill: '#000000',
      textColor: '#000000',
      textSize: 12,
      linkColor: '#3a3f4b',
      linkStrokeWidth: 1.2,
    };

    function createGraph(container, nodes, links, options = {}) {
      const CIRCLE_RADIUS = options.circleRadius ?? CONFIG.circleRadius;
      const SPRING_LENGTH = options.springLength ?? CONFIG.springLength;
      const SPRING_FORCE = options.springStrength ?? CONFIG.springStrength;
      const REPULSION_FORCE = options.repulsion ?? CONFIG.repulsion;
      const DAMPING = options.damping ?? CONFIG.damping;

      container.classList.add("obsidian-graph");

      const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
      const viewport = document.createElementNS(svg.namespaceURI, "g");
      svg.appendChild(viewport);
      container.appendChild(svg);

      const bounds = () => container.getBoundingClientRect();

      let scale = 1;
      let panX = 0;
      let panY = 0;
      let panning = false;

      const nodeById = Object.fromEntries(nodes.map(n => [n.id, n]));

      // INITIAL SPAWN - circular arrangement
      const spawnRadius = 140;
      nodes.forEach((n, i) => {
        const angle = (i / nodes.length) * Math.PI * 2;
        n.x = Math.cos(angle) * spawnRadius;
        n.y = Math.sin(angle) * spawnRadius;
        n.vx = 0;
        n.vy = 0;
      });

      // Create links
      const linkEls = links.map(l => {
        const el = document.createElementNS(svg.namespaceURI, "line");
        el.classList.add("link");
        viewport.appendChild(el);
        return {
          el,
          a: nodeById[l.a],
          b: nodeById[l.b]
        };
      });

      // Create nodes
      const nodeEls = nodes.map(n => {
        const g = document.createElementNS(svg.namespaceURI, "g");
        g.classList.add("node");
        g.style.userSelect = "none";

        const circle = document.createElementNS(svg.namespaceURI, "circle");
        circle.setAttribute("r", CIRCLE_RADIUS);

        const text = document.createElementNS(svg.namespaceURI, "text");
        text.setAttribute("y", CIRCLE_RADIUS + 15);
        text.textContent = n.id;

        g.appendChild(circle);
        g.appendChild(text);
        viewport.appendChild(g);

        // Handle click navigation
        if (n.url) {
          g.addEventListener("click", () => {
            window.location.href = n.url;
          });
        }

        enableDrag(g, n);
        return { g, n };
      });

      // Physics simulation
      function tick() {
        // Spring forces
        for (const l of linkEls) {
          const dx = l.b.x - l.a.x;
          const dy = l.b.y - l.a.y;
          const d = Math.hypot(dx, dy) || 1;
          const force = (d - SPRING_LENGTH) * SPRING_FORCE;
          const fx = (force * dx) / d;
          const fy = (force * dy) / d;

          l.a.vx += fx;
          l.a.vy += fy;
          l.b.vx -= fx;
          l.b.vy -= fy;
        }

        // Repulsion forces
        for (let i = 0; i < nodes.length; i++) {
          for (let j = i + 1; j < nodes.length; j++) {
            const a = nodes[i];
            const b = nodes[j];
            const dx = b.x - a.x;
            const dy = b.y - a.y;
            const d2 = dx * dx + dy * dy;

            if (d2 > 40000) continue;

            const d = Math.sqrt(d2) || 1;
            const force = REPULSION_FORCE / d2;
            const fx = (force * dx) / d;
            const fy = (force * dy) / d;

            a.vx -= fx;
            a.vy -= fy;
            b.vx += fx;
            b.vy += fy;
          }
        }

        // Integrate velocities
        for (const n of nodes) {
          n.x += n.vx;
          n.y += n.vy;
          n.vx *= DAMPING;
          n.vy *= DAMPING;
        }

        render();
        requestAnimationFrame(tick);
      }

      function render() {
        // Update links
        for (const l of linkEls) {
          l.el.setAttribute("x1", l.a.x);
          l.el.setAttribute("y1", l.a.y);
          l.el.setAttribute("x2", l.b.x);
          l.el.setAttribute("y2", l.b.y);
        }

        // Update nodes
        for (const o of nodeEls) {
          o.g.setAttribute("transform", `translate(${o.n.x}, ${o.n.y})`);
        }
      }

      function enableDrag(el, n) {
        let isDragging = false;

        el.addEventListener("mousedown", e => {
          isDragging = true;
          e.stopPropagation();
        });

        window.addEventListener("mousemove", e => {
          if (!isDragging) return;
          n.x += e.movementX / scale;
          n.y += e.movementY / scale;
          n.vx = 0;
          n.vy = 0;
        });

        window.addEventListener("mouseup", () => {
          isDragging = false;
        });
      }

      function centerGraph() {
        let minX = Infinity,
          minY = Infinity,
          maxX = -Infinity,
          maxY = -Infinity;

        for (const n of nodes) {
          minX = Math.min(minX, n.x);
          minY = Math.min(minY, n.y);
          maxX = Math.max(maxX, n.x);
          maxY = Math.max(maxY, n.y);
        }

        const centerX = (minX + maxX) / 2;
        const centerY = (minY + maxY) / 2;
        const b = bounds();

        panX = b.width / 2 - centerX * scale;
        panY = b.height / 2 - centerY * scale;
        updateView();
      }

      function updateView() {
        viewport.setAttribute("transform", `translate(${panX}, ${panY}) scale(${scale})`);
      }

      // Zoom
      svg.addEventListener("wheel", e => {
        e.preventDefault();
        const oldScale = scale;
        scale *= e.deltaY > 0 ? 0.9 : 1.1;
        updateView();
      });

      // Pan
      svg.addEventListener("mousedown", e => {
        if (e.target === svg) {
          panning = true;
          svg.classList.add("panning");
        }
      });

      window.addEventListener("mousemove", e => {
        if (!panning) return;
        panX += e.movementX;
        panY += e.movementY;
        updateView();
      });

      window.addEventListener("mouseup", () => {
        panning = false;
        svg.classList.remove("panning");
      });

      // Observe container resize
      new ResizeObserver(() => {
        centerGraph();
      }).observe(container);

      // Start simulation
      centerGraph();
      tick();
    }

    // Example data
    const nodes = [
      { id: "Note A", url: "#A" },
      { id: "Note B", url: "#B" },
      { id: "Note C", url: "#C" },
      { id: "Note D", url: "#D" },
      { id: "Note E", url: "#E" }
    ];

    const links = [
      { a: "Note A", b: "Note B" },
      { a: "Note A", b: "Note C" },
      { a: "Note B", b: "Note D" },
      { a: "Note C", b: "Note D" },
      { a: "Note D", b: "Note E" }
    ];

    // Initialize graph
    document.addEventListener("DOMContentLoaded", () => {
      createGraph(document.getElementById("graph"), nodes, links);
    });
  </script>